#include<cstdlib>
#include<cassert>
#include<cstdio>
#include<sys/types.h>
#include<unistd.h>
#include<time.h>
#include<cmath>

#include<fstream>
#include<map>
#include<vector>
#include<string>
#include<iostream>
#include<numeric>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/one_bit_color_map.hpp>
#include <boost/graph/stoer_wagner_min_cut.hpp>
#include <boost/property_map/property_map.hpp>
#include <boost/typeof/typeof.hpp>
#include <boost/graph/kruskal_min_spanning_tree.hpp>


#include <boost/graph/metric_tsp_approx.hpp>

#include <gmpxx.h>

#include "boost/random.hpp"
#include "boost/generator_iterator.hpp"

//#define INSTALLED_PREFIX "/import/crl-linhome/home/1/cgretton/Work2014/Software/Shapley_TSP_Approximations/" // TO-DO
//#define INSTALLED_PREFIX "/tmp/ram/Concorde-0/"
//#define INSTALLED_PREFIX "/home/cgretton/Work2013/Software/Shapley_TSP_Approximations/"// TO-DO

using namespace std;

/* For games with the number of players ranging from
 * \global{lower_range} to \global{upper_range}, we sample
 * \global{num_samples} problems and calculate the Shapley value and
 * proxies. When using ApproShapley to calculate the Shapley value, we
 * take \global{num_samples_approShapley} samples -- Recall, this is
 * the number of sampled permutations, or equivalently the number of
 * sampled margins for each player.*/
int lower_range;
int upper_range;
int num_samples;
int num_samples_approShapley;

/* When sampling tours from an MST, we take the following number of samples.*/
int MST_CIRCUIT_SAMPLES;

/* Parses a tour generated by Concorde. First element in return is the
 * length of the tour. Second element is the marginal cost of
 * including each customer in the optimal grand tour (first customer,
 * second customer, etc). */
pair<double, vector<double> >  parse_tour(ifstream& in, double(*distance_calc)(int i, int j));

/* Point with ID 0 is going to be the depot. */
bool are_we_solving_a_problem_with_a_single_depot = true;

/* When generating scenarios using pseudo-random points, this is the size of the chart the points are placed on.*/
double chart_magnitude;

/*Number of points in the game presently under consideration.*/
size_t points_count;

typedef pair<double, double> Point; /* Euclidean points.*/
vector<Point> points; /* Vector of Euclidean points in a plane.*/
vector<vector<double> > matrix; /* We implement functionality to treat problems where the inputs are given in distance matrix format. */
string concorde_file_name; /* The filename that determines where the Concorde inputs are written.*/
string model_file_name;/* In the case that the input model is parsed from a file, this is the filename associated with that model. */


/* True when software is calculating allocations using an exact TSP solution procedure.*/
bool tspmode = false;


/* Implementation of the numerical "factorial" function.*/
mpz_class fact(unsigned int n)
{
        mpz_class result(n);
        while(n --> 1) result *= n;
        return result;
}

/* Edge between two vertices identified with positive integer weights.*/
struct edge_t
{
  size_t first;
  size_t second;
};

/* Calculate the distance between two players in a symmetric or
 * asymmetric TSP Game. Here, if the distance matrix is asymmetric, in
 * the case that \argument{asym} is false we induce a symmetric model
 * by taking the longest of the i->j and j->k lengths.*/
double calc_distance_matrix(int i, int j, bool asym = false){    
    if(i == j) return 999.0;//=0.0;
    //return (i<j)?matrix[i][j]:matrix[j][i];
    if(asym) return matrix[i][j]; else return std::max(matrix[i][j], matrix[j][i]);//std::min(matrix[i][j], matrix[j][i]);//std::max(matrix[i][j], matrix[j][i]);
}

/* Calculate the distance between two players in a (presumably) asymmetric TSP Game. */
double calc_distance_matrix__asym(int i, int j){ 
    if(i == j ) return 0;

    return 100.0 * calc_distance_matrix(i, j, true);
}

double update_distance_matrix__sym(int i, int j, double new_value){
    matrix[i][j] = new_value;
    matrix[j][i] = new_value;
}

void iterate__triangle_innequality_test_and_repair(){

    bool violations = false;
    for (int i = 0; i < points.size(); i++){
        for (int j = i+1; j < points.size(); j++){
            for (int k = 0; k < points.size(); k++){
                if (k == i || k == j) continue;
                
                if (matrix[i][k] > matrix[i][j] + matrix[j][k]){
                    violations = true;
                    update_distance_matrix__sym(i, k, matrix[i][j] + matrix[j][k]);
                    
                    break;
                }
            }
            if(violations){
                break;
            }
        }
        if(violations){
            break;
        }
    }

    if(violations){
        cerr<<"Bad triangles.\n";
        iterate__triangle_innequality_test_and_repair();
    }
}

/* Calculate the distance between two players in a (forced) symmetric TSP Game. */
double calc_distance_matrix__sym(int i, int j){ 
    return 10.0 * calc_distance_matrix(i, j, false);
}

/* Euclidean distance between the point at index $i$ and the point at index $j$.*/
double calc_distance(int i, int j){
    if(i == j) return 0.0;
    
    double x1 = points[i].first;
    double y1 = points[i].second;
          
    double x2 = points[j].first;
    double y2 = points[j].second;
          
    double dist = sqrt((x1 - x2) * (x1 - x2)  + (y1 - y2) * (y1 - y2)  );

    return dist;
}



double(*COST_OF_EDGE__FUNCTION)(int i, int j);
void(*WRITING_TO_CONCORDE__FUNCTION)(const set<int>& local_points);


#include "input_output.hh"

#include "Shapley.hh"

#include "proxies.hh"

#include "model_generation.hh"

#include "experimental_design.hh"

bool asymmetric_games = false;

int main__Euclidean_experiment(int argc, char** argv){
    long my_seed;
    assert(argc>=7);
    lower_range = atoi(argv[1]);//Look at TSP models with this many data points...
    upper_range = atoi(argv[2]);//Up-to this many data points (can be equal above (lower) bound).
    num_samples = atoi(argv[3]);//Not approshapley, but number of samples of models of each size.
    concorde_file_name = string(argv[4]);//File name for concorde inputs.
    chart_magnitude = atoi(argv[5]);//Size of map in units (say 1000). 
    MST_CIRCUIT_SAMPLES = atoi(argv[6]);//When using TMST, how many circuits should I generate?
    num_samples_approShapley = atoi(argv[7]);//Number of samples for ApproShapley.

    if(argc==9){// Nick, you can ignore this one, I did experiments with asymmetric games at one point (always 0)
        asymmetric_games = atoi(argv[8]);
    }
    time_t t1; (void) time(&t1);
    srand48((long) t1);
    if(argc==10){
        my_seed = atoi(argv[9]); // Random seed.
        srand48((long) my_seed);
    }

    
    if(!asymmetric_games){
        cerr<<"Setting up for symmetric Euclidean games.\n";
        COST_OF_EDGE__FUNCTION = calc_distance;
        WRITING_TO_CONCORDE__FUNCTION = write__for_concorde;
    } else {
        cerr<<"Asymmetric game... \n";
        COST_OF_EDGE__FUNCTION = calc_distance_matrix__sym;
        WRITING_TO_CONCORDE__FUNCTION = write__for_concorde__matrix;
    }
    
    main_loop();
    
    write_raw_samples();
    write_ratio_data();
    //write_ranking_data();// Deemed uninteresting.
    write_apportionment();
    write_prescription_data();
    write_group_prescription_data();
    
    return 0;
}

int main__Single_Euclidean_data_point(int argc, char** argv){
    model_file_name = string(argv[1]);
    concorde_file_name = string(argv[2]);
    num_samples_approShapley = atoi(argv[3]);
    
    parse_Euclidean_tsplib_model(model_file_name);

    COST_OF_EDGE__FUNCTION = calc_distance;
    WRITING_TO_CONCORDE__FUNCTION = write__for_concorde;

    one_point_experiment__Euclidean();

    write_raw_samples();
    write_ratio_data();
    write_apportionment();
    write_prescription_data();
    write_group_prescription_data();
}

int main__Single_Matrix_data_point__Concorde(int argc, char** argv){
    cerr<<"Running SME.\n";
    
    model_file_name = string(argv[1]);
    concorde_file_name = string(argv[2]);
    num_samples_approShapley = atoi(argv[3]);  

    cerr<<"Parsing.\n";
    parse_matrix_tsplib_model(model_file_name);
    cerr<<"Done parsing.\n";
    
    COST_OF_EDGE__FUNCTION = calc_distance_matrix__sym;
    WRITING_TO_CONCORDE__FUNCTION = write__for_concorde__matrix;

    /* Ensure the triangle innequality is respected during transformation.*/
    iterate__triangle_innequality_test_and_repair();

    one_point_experiment__matrix();
    
    write_raw_samples();
    write_ratio_data();
    write_apportionment();
    write_prescription_data();
    write_group_prescription_data();
}


int main__Single_Matrix_data_point__Indigo(int argc, char** argv){
    cerr<<"Running SME.\n";
    
    model_file_name = string(argv[1]);
    concorde_file_name = string(argv[2]);
    num_samples_approShapley = atoi(argv[3]);  

    cerr<<"Parsing.\n";
    parse_matrix_tsplib_model(model_file_name);
    cerr<<"Done parsing.\n";
    
    COST_OF_EDGE__FUNCTION = calc_distance_matrix__asym;
    WRITING_TO_CONCORDE__FUNCTION = write__for_indigo__matrix;

    one_point_experiment__matrix();
    
    write_raw_samples();
    write_ratio_data();
    write_apportionment();
    write_prescription_data();
    write_group_prescription_data();
}

int main(int argc, char** argv){
    cerr<<"Running binary named : "<< argv[0]<<endl;
    
    if(string("./shapley_experiment") == string(argv[0])){
        return main__Euclidean_experiment(argc, argv);
    } else if (string("./one_point_Euclidean_experiment") == string(argv[0])) {
        main__Single_Euclidean_data_point(argc, argv);
    } else if (string("./one_point_matrix_experiment") == string(argv[0])) {
        main__Single_Matrix_data_point__Concorde(argc, argv);
        //main__Single_Matrix_data_point__Indigo(argc, argv);
    }

    return -1;
}
